
## Problem Statement
Given an integer array `nums` and an integer `target`, 
find two distinct indices (0-based) such that the sum of the elements
at those indices equals the target. Each input has exactly one solution, 
the same element cannot be used twice, and the result must be returned 
in increasing order of indices.


## Test Cases

### Test Case 1
Input:
nums = [1, 6, 2, 10, 3]  
target = 7  

Output:
[0, 1]

---

### Test Case 2
Input:
nums = [1, 3, 5, -7, 6, -3]  
target = 0  

Output:
[1, 5]

---

### Test Case 3
Input:
nums = [-6, 7, 1, -7, 6, 2]  
target = 3  

Output:
[2, 5]

---

## Approach
Traverse the array once while storing previously seen elements in a HashMap.  
For each element, calculate the complement required to reach the target.  
If the complement exists in the map, return both indices. Otherwise, store the current element and its index.

---

## Time & Space Complexity
Time Complexity: O(n)  
Space Complexity: O(n)

---

## Code
import java.util.HashMap;
import java.util.Map;

class Solution {

    public int[] twoSum(int[] nums, int target) {

        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];

            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }

            map.put(nums[i], i);
        }

        // Problem guarantees exactly one solution
        return new int[]{};
    }
}
